####Split Conformal####
#no need of test grid, nor loops.
n=40
y=rt(n,2)
test_grid=seq(-grid_factor*max(abs(y)),+grid_factor*max(abs(y)),length.out = n_grid)
####Split Conformal####
#no need of test grid, nor loops.
n=40
y=rt(n,2)
test_grid=seq(-grid_factor*max(abs(y)),+grid_factor*max(abs(y)),length.out = n_grid)
pval_fun=sapply(test_grid,wrapper_full)
plot(test_grid,pval_fun,type='l')
index_in=pval_fun>alpha
wrapper_full=function(grid_point){
aug_y=c(grid_point,y_b)
mu=mean(aug_y)
ncm=abs(mu - aug_y)
sum((ncm[-1]>=ncm[1]))/(n+1)
}
####Split Conformal####
#no need of test grid, nor loops.
n=40
y=rt(n,2)
test_grid=seq(-grid_factor*max(abs(y)),+grid_factor*max(abs(y)),length.out = n_grid)
# The daset lung of survival package is related to patients with advanced lung cancer from the North Central
# Cancer Treatment Group. Performance scores rate how well the patient can perform usual daily activities.
help(lung)
# Load the data
data("lung")
dim(lung)
head(lung)
library(survival)
library(survminer)
library(dplyr)
# The daset lung of survival package is related to patients with advanced lung cancer from the North Central
# Cancer Treatment Group. Performance scores rate how well the patient can perform usual daily activities.
help(lung)
# Load the data
data("lung")
dim(lung)
head(lung)
#---------------------------#
# Univariate Cox regression #
#---------------------------#
# Considr the continuous variable age and fit a Cox regression model.
cox.age <- coxph(Surv(time, status) ~ age, data = lung)
cox.age
# The function summary() for Cox models produces a more complete report:
summary(cox.age)
# Plot the baseline survival function S_0(t)
plot(survfit(cox.age, data=lung),
col="darkorange2", lwd=2, lty=1,
xlab='Time [days]', ylab='Survival Probability',
main='Baseline estimated survival probability')
grid()
# Suppose we want to consider ages equal to 50, 65 and 80. We create the new data:
summary(lung$age)
age_df <- with(lung,
data.frame(age = c(50,65,80) )
)
age_df
# This data frame is passed to survfit() via the newdata argument to estimate survival:
fit.age <- survfit(cox.age, newdata = age_df)
fit.age
# Estimated survival curves plot:
x11()
plot(fit.age, conf.int=T,
col=c("dodgerblue2","navy","darkmagenta"), lwd=2, lty=1,
xlab='Time [days]', ylab='Survival Probability',
main='Adjusted Survival Probability Plot')
grid()
legend('topright', c("Age = 50", "Age = 65", "Age = 80"),
lty=c(1,1,1), lwd=c(2,2,2), col=c("dodgerblue2","navy","darkmagenta"))
# Suppose we want to consider ages equal to 50, 65 and 80. We create the new data:
summary(lung$age)
fit.age
# Estimated survival curves plot:
x11()
plot(fit.age, conf.int=T,
col=c("dodgerblue2","navy","darkmagenta"), lwd=2, lty=1,
xlab='Time [days]', ylab='Survival Probability',
main='Adjusted Survival Probability Plot')
grid()
legend('topright', c("Age = 50", "Age = 65", "Age = 80"),
lty=c(1,1,1), lwd=c(2,2,2), col=c("dodgerblue2","navy","darkmagenta"))
# Check if you categorical covariates are considered factors:
summary(lung)
lung$sex <- ifelse(lung$sex==1,'Male','Female')
lung$sex <- as.factor(lung$sex)
summary(lung)
# Fit the Cox's regression model:
mod.cox <- coxph(Surv(time, status) ~ age + sex + ph.karno + wt.loss, data =  lung)
summary(mod.cox)
# Visualizing Hazard ratios #
#---------------------------#
# You can visualize Hr and its CIs using the ggforest() function of package survminer:
x11()
ggforest(mod.cox, data=lung)
# Visualizing Hazard ratios #
#---------------------------#
# You can visualize Hr and its CIs using the ggforest() function of package survminer:
x11()
ggforest(mod.cox, data=lung)
# Plot the baseline survival function S_0(t)
x11()
plot(survfit(mod.cox, data=lung),
col="darkorange2", lwd=2, lty=1,
xlab='Time [days]', ylab='Survival Probability',
main='Baseline estimated survival probability')
grid()
# AGE #
#-----#
# Create the new data :
summary(lung$age)
age_df <- with(lung,
data.frame(age = c(50,65,80),
sex = rep('Male',3),
ph.karno = rep(median(lung$pat.karno, na.rm=T),3),
wt.loss = rep(median(lung$wt.loss, na.rm=T),3))
)
age_df
# This data frame is passed to survfit() via the newdata argument:
fit.age <- survfit(mod.cox, newdata = age_df)
fit.age
# Estimated survival curves:
x11()
plot(fit.age, conf.int=T,
col=c("dodgerblue2","navy","darkmagenta"), lwd=2, lty=1,
xlab='Time [days]', ylab='Survival Probability',
main='Adjusted Survival Probability Plot -- Age')
grid()
legend('topright', c("Age = 50", "Age = 65", "Age = 80"),
lty=c(1,1,1), lwd=c(2,2,2), col=c("dodgerblue2","navy","darkmagenta"))
# AGE #
#-----#
# Create the new data :
summary(lung$age)
age_df <- with(lung,
data.frame(age = c(50,65,80),
sex = rep('Male',3),
ph.karno = rep(median(lung$pat.karno, na.rm=T),3),
wt.loss = rep(median(lung$wt.loss, na.rm=T),3))
)
head(lung))
head(lung)
# AGE #
#-----#
# Create the new data :
summary(lung$age)
age_df <- with(lung,
data.frame(age = c(50,65,80),
sex = rep('Male',3),
ph.karno = rep(median(lung$ph.karno, na.rm=T),3),
wt.loss = rep(median(lung$wt.loss, na.rm=T),3))
)
age_df
# This data frame is passed to survfit() via the newdata argument:
fit.age <- survfit(mod.cox, newdata = age_df)
fit.age
# Estimated survival curves:
x11()
plot(fit.age, conf.int=T,
col=c("dodgerblue2","navy","darkmagenta"), lwd=2, lty=1,
xlab='Time [days]', ylab='Survival Probability',
main='Adjusted Survival Probability Plot -- Age')
grid()
legend('topright', c("Age = 50", "Age = 65", "Age = 80"),
lty=c(1,1,1), lwd=c(2,2,2), col=c("dodgerblue2","navy","darkmagenta"))
# Plot martingale residuals
x11()
plot(predict(mod.cox), residuals(mod.cox, type='martingale'),
xlab='Fitted values', ylab='Martingale residuals', main='Residual Plot', las=1)
# Add a line for residual=0
abline(h=0, col='red')
# Fit a smoother for the points
lines(smooth.spline(predict(mod.cox), residuals(mod.cox, type='martingale')), col='blue')
# Alternatively
x11()
ggcoxdiagnostics(mod.cox, type = "martingale")
# Sometimes, martingale residuals are difficult to be interpreted.
# The deviance residual is a normalized transform of the martingale residual.
# These residuals should be roughly symmetrically distributed about zero with a standard deviation of 1.
#     - Positive values correspond to individuals that "died too soon" compared to expected survival times.
#     - Negative values correspond to individual that "lived too long".
#     - Very large or small values are outliers, which are poorly predicted by the model.
# It's also possible to check outliers by visualizing the deviance residuals.
# Example of deviance residuals:
x11()
ggcoxdiagnostics(mod.cox, type = "deviance")
x11()
ggcoxdiagnostics(mod.cox, type = "schoenfeld")
# We consider the KM estimators for sex variable:
sex.km <- survfit(Surv(time, status) ~ sex, data = lung[!is.na(lung$wt.loss) & !is.na(lung$ph.karno),])
# We plot log(-log(KM(t))) using option fun='cloglog' in plot.survfit()
help(plot.survfit)
x11()
plot(sex.km, fun='cloglog',
col=c("deeppink2","dodgerblue2"), lwd=2, lty=1,
ylab="log(-log(Survival Probability))")
grid()
legend('topleft', c("Female", "Male"),
lty=c(1,1), lwd=c(2,2), col=c("deeppink2","dodgerblue2"))
# Test for PH using scaled Schoenfeld test for PH
# H0: Hazards are proportional
# H1: Hazards are NOT proportional
# cox.zph() return tests for each X and for the global model
test.ph <- cox.zph(mod.cox)
test.ph
# alternatively:
x11()
ggcoxdiagnostics(mod.cox, type = "scaledsch")
graphics.off()
# alternatively:
x11()
ggcoxdiagnostics(mod.cox, type = "scaledsch")
library(readr)
Data <- read_csv("C:/Users/aughi/Desktop/Hierarchical Bayesian Nonparametric models to smooth functional data/MultipleThrowsDataGeneration/Data.csv")
View(Data)
library(mgcv)
model_gam=gam(prestige ~ s(education,bs='cr') + s(income,bs='cr'))
attach(Prestige)
model_poly=lm(prestige ~ income)
income.grid=seq(range(income)[1],range(income)[2],by=100)
preds=predict(model_poly,list(income=income.grid),se=T)
plot(income ,prestige ,xlim=range(income.grid) ,cex =.5, col =" darkgrey ",main='linear')
lines(income.grid,preds$fit ,lwd =2, col =" blue")
#how to generate conformal predictions?
lm_train=lm.funs(intercept = T)$train.fun
lm_predict=lm.funs(intercept = T)$predict.fun
#design_matrix=matrix(poly(income,degree=2),ncol=2)
c_preds=conformal.pred(income,prestige,income.grid,alpha=0.05,verbose=T,train.fun = lm_train,predict.fun = lm_predict,num.grid.pts = 200)
lines(income.grid,c_preds$pred ,lwd =2, col ="red",lty=3)
matlines(income.grid ,cbind(c_preds$up,c_preds$lo) ,lwd =1, col =" blue",lty =3)
#let's go a bit more complex:
model_poly=lm(prestige ~ poly(income,degree=2))
income.grid=seq(range(income)[1],range(income)[2],by=100)
preds=predict(model_poly,list(income=income.grid),se=T)
plot(income ,prestige ,xlim=range(income.grid) ,cex =.5, col =" darkgrey ",main='linear')
lines(income.grid,preds$fit ,lwd =2, col =" blue")
design_matrix=matrix(poly(income,degree=2),ncol=2)
pred_grid=matrix(poly(income.grid,degree=2,coefs = attr(poly(income,degree=2),"coefs") ),ncol=2)
c_preds=conformal.pred(design_matrix,prestige,pred_grid,alpha=0.05,verbose=T,train.fun = lm_train,predict.fun = lm_predict,num.grid.pts = 200)
lines(income.grid,c_preds$pred ,lwd =2, col ="red",lty=3)
matlines(income.grid ,cbind(c_preds$up,c_preds$lo) ,lwd =1, col =" blue",lty =3)
#how to it in a split fashion?
plot(income ,prestige ,xlim=range(income.grid) ,cex =.5, col =" darkgrey ",main='linear')
lines(income.grid,preds$fit ,lwd =2, col =" blue")
c_preds_split=conformal.pred.split(design_matrix,prestige,pred_grid,alpha=0.05,verbose=T,train.fun = lm_train,predict.fun = lm_predict,)
lines(income.grid,c_preds_split$pred ,lwd =2, col ="red",lty=3)
matlines(income.grid ,cbind(c_preds_split$up,c_preds_split$lo) ,lwd =1, col =" red",lty =3)
c_preds_split=conformal.pred.split(design_matrix,prestige,pred_grid,alpha=0.05,verbose=T,train.fun = lm_train,predict.fun = lm_predict)
lines(income.grid,c_preds_split$pred ,lwd =2, col ="green",lty=3)
matlines(income.grid ,cbind(c_preds_split$up,c_preds_split$lo) ,lwd =1, col =" green",lty =3)
c_preds_split=conformal.pred.split(design_matrix,prestige,pred_grid,alpha=0.05,verbose=T,train.fun = lm_train,predict.fun = lm_predict)
lines(income.grid,c_preds_split$pred ,lwd =2, col ="orange",lty=3)
matlines(income.grid ,cbind(c_preds_split$up,c_preds_split$lo) ,lwd =1, col =" orange",lty =3)
#as long as I am using the lm framework, everything tends to be very easy...
library(splines)
br=c(quantile(income,probs = c(0.2,0.4,0.6,0.8)),15000)
model_cut=lm(prestige ~ bs(income, degree=3,knots=br))
preds=predict(model_cut,list(income=income.grid),se=T)
plot(income ,prestige ,xlim=range(income.grid) ,cex =.5, col =" darkgrey " )
lines(income.grid,preds$fit ,lwd =2, col =" blue")
design_matrix=bs(income, degree=3,knots=br)
pred_grid=matrix(bs(income.grid,degree=3,knots=br),nrow=length(income.grid))
c_preds=conformal.pred(design_matrix,prestige,pred_grid,alpha=0.05,verbose=T,train.fun = lm_train,predict.fun = lm_predict,num.grid.pts = 200)
lines(income.grid,c_preds$pred ,lwd =2, col ="red",lty=3)
matlines(income.grid ,cbind(c_preds$up,c_preds$lo) ,lwd =1, col =" blue",lty =3)
#What if we cannot use the lm framework? we need to come up with something different...
fit=smooth.spline(income,prestige,cv=T)
plot(income ,prestige,cex =.5, col =" darkgrey ")
lines(fit,col="blue",lwd=2)
opt = fit$df
opt
fit$lambda
#a procedure like this takes also into account the choice of the correct smoothing value
train_ss=function(x,y,out=NULL){
smooth.spline(x,y,df=opt)
}
predict_ss=function(obj, new_x){
predict(obj,new_x)$y
}
pippo=train_ss(income,prestige)
predict_ss(pippo,income)
c_preds=conformal.pred(income,prestige,income.grid,alpha=0.05,verbose=T,train.fun = train_ss ,predict.fun = predict_ss,num.grid.pts = 200)
lines(income.grid,c_preds$pred ,lwd =2, col ="red",lty=3)
matlines(income.grid ,cbind(c_preds$up,c_preds$lo) ,lwd =1, col =" blue",lty =3)
#let's try to do it in a more complex case... GAMS
library
attach(Prestige)
model_poly=lm(prestige ~ income)
income.grid=seq(range(income)[1],range(income)[2],by=100)
preds=predict(model_poly,list(income=income.grid),se=T)
plot(income ,prestige ,xlim=range(income.grid) ,cex =.5, col =" darkgrey ",main='linear')
lines(income.grid,preds$fit ,lwd =2, col =" blue")
#how to generate conformal predictions?
lm_train=lm.funs(intercept = T)$train.fun
lm_predict=lm.funs(intercept = T)$predict.fun
#design_matrix=matrix(poly(income,degree=2),ncol=2)
c_preds=conformal.pred(income,prestige,income.grid,alpha=0.05,verbose=T,train.fun = lm_train,predict.fun = lm_predict,num.grid.pts = 200)
lines(income.grid,c_preds$pred ,lwd =2, col ="red",lty=3)
matlines(income.grid ,cbind(c_preds$up,c_preds$lo) ,lwd =1, col =" blue",lty =3)
#let's go a bit more complex:
model_poly=lm(prestige ~ poly(income,degree=2))
income.grid=seq(range(income)[1],range(income)[2],by=100)
preds=predict(model_poly,list(income=income.grid),se=T)
plot(income ,prestige ,xlim=range(income.grid) ,cex =.5, col =" darkgrey ",main='linear')
lines(income.grid,preds$fit ,lwd =2, col =" blue")
design_matrix=matrix(poly(income,degree=2),ncol=2)
pred_grid=matrix(poly(income.grid,degree=2,coefs = attr(poly(income,degree=2),"coefs") ),ncol=2)
c_preds=conformal.pred(design_matrix,prestige,pred_grid,alpha=0.05,verbose=T,train.fun = lm_train,predict.fun = lm_predict,num.grid.pts = 200)
lines(income.grid,c_preds$pred ,lwd =2, col ="red",lty=3)
matlines(income.grid ,cbind(c_preds$up,c_preds$lo) ,lwd =1, col =" blue",lty =3)
#how to it in a split fashion?
plot(income ,prestige ,xlim=range(income.grid) ,cex =.5, col =" darkgrey ",main='linear')
lines(income.grid,preds$fit ,lwd =2, col =" blue")
c_preds_split=conformal.pred.split(design_matrix,prestige,pred_grid,alpha=0.05,verbose=T,train.fun = lm_train,predict.fun = lm_predict,)
lines(income.grid,c_preds_split$pred ,lwd =2, col ="red",lty=3)
matlines(income.grid ,cbind(c_preds_split$up,c_preds_split$lo) ,lwd =1, col =" red",lty =3)
c_preds_split=conformal.pred.split(design_matrix,prestige,pred_grid,alpha=0.05,verbose=T,train.fun = lm_train,predict.fun = lm_predict)
lines(income.grid,c_preds_split$pred ,lwd =2, col ="green",lty=3)
matlines(income.grid ,cbind(c_preds_split$up,c_preds_split$lo) ,lwd =1, col =" green",lty =3)
c_preds_split=conformal.pred.split(design_matrix,prestige,pred_grid,alpha=0.05,verbose=T,train.fun = lm_train,predict.fun = lm_predict)
lines(income.grid,c_preds_split$pred ,lwd =2, col ="orange",lty=3)
matlines(income.grid ,cbind(c_preds_split$up,c_preds_split$lo) ,lwd =1, col =" orange",lty =3)
#as long as I am using the lm framework, everything tends to be very easy...
library(splines)
br=c(quantile(income,probs = c(0.2,0.4,0.6,0.8)),15000)
model_cut=lm(prestige ~ bs(income, degree=3,knots=br))
preds=predict(model_cut,list(income=income.grid),se=T)
plot(income ,prestige ,xlim=range(income.grid) ,cex =.5, col =" darkgrey " )
lines(income.grid,preds$fit ,lwd =2, col =" blue")
design_matrix=bs(income, degree=3,knots=br)
pred_grid=matrix(bs(income.grid,degree=3,knots=br),nrow=length(income.grid))
c_preds=conformal.pred(design_matrix,prestige,pred_grid,alpha=0.05,verbose=T,train.fun = lm_train,predict.fun = lm_predict,num.grid.pts = 200)
lines(income.grid,c_preds$pred ,lwd =2, col ="red",lty=3)
matlines(income.grid ,cbind(c_preds$up,c_preds$lo) ,lwd =1, col =" blue",lty =3)
#What if we cannot use the lm framework? we need to come up with something different...
fit=smooth.spline(income,prestige,cv=T)
plot(income ,prestige,cex =.5, col =" darkgrey ")
lines(fit,col="blue",lwd=2)
opt = fit$df
opt
fit$lambda
#a procedure like this takes also into account the choice of the correct smoothing value
train_ss=function(x,y,out=NULL){
smooth.spline(x,y,df=opt)
}
predict_ss=function(obj, new_x){
predict(obj,new_x)$y
}
pippo=train_ss(income,prestige)
predict_ss(pippo,income)
c_preds=conformal.pred(income,prestige,income.grid,alpha=0.05,verbose=T,train.fun = train_ss ,predict.fun = predict_ss,num.grid.pts = 200)
lines(income.grid,c_preds$pred ,lwd =2, col ="red",lty=3)
matlines(income.grid ,cbind(c_preds$up,c_preds$lo) ,lwd =1, col =" blue",lty =3)
#let's try to do it in a more complex case... GAMS
library
library(mgcv)
model_gam=gam(prestige ~ s(education,bs='cr') + s(income,bs='cr'))
help(psm)
library(mcclust.ext)
comp.psm
help(comp.psm)
help(heatmap)
help("heatmap")
help(psm)
help(heatmap)
help(image)
help(heatmap)
install.packages("garchx")
garchx::garchx
load("C:\\Users\\aughi\\AppData\\Local\\Temp\\Temp1_dati_HF_sample.zip\\dati_HF_sample.RData")
View(test.ph)
View(age_df)
View(bla)
View(cox.age)
View(cox.age)
View(lung)
## COXME model
coxme.mod <- coxme(Surv(GapEvent,event) ~ SESSO + ADERENTE + etaEvent + comorbidity + (1|COD_REG), data = data)
################################ COX MIXED EFFECT MODEL ###########################################
## Load packages
rm(list = ls())
library(data.table)
library(survival)
library(survminer)
library(coxme)
## Load Dataset
load("With_Adherence_Dataset/ACE_Inhibitors.RData")
## Arrange Dataset
# histogram
per_hist=new[is.na(hosp)==F,max(hosp),by=COD_REG]
hist(per_hist$V1)
# time at hospitalization events
new[!is.na(hosp), timeEvent:= data_prest - data_rif_ev]
# eta at hospitalization events
new[!is.na(hosp), etaEvent:= eta_Min]
# numbers of comorbidity at hospitalization events discharge
new[!is.na(hosp), comorbidity:=rowSums(.SD), .SDcols = 36:55]
# flag for event
new[!is.na(hosp), event:= 1]
# flag for type of censoring
new[!is.na(hosp), cens:=NA]
## build dataset
# key: COD_REG
# flag: event
# time: timeEvent
# patient level: SESSO, ADERENTE
# event level: eta_event, comorbidity
data <- subset(new,hosp>=1,select = c(COD_REG,event,timeEvent,SESSO,ADERENTE,etaEvent,comorbidity,cens))
names(data)
# add censoring event per patient
codici<- unique(data$COD_REG)
for(i in 1:length(codici)){
paz_corrente <- codici[i]
temp <- data.frame(paz_corrente,0,unique(new[COD_REG==paz_corrente]$timeOUT),unique(new[COD_REG==paz_corrente]$SESSO),
unique(new[COD_REG==paz_corrente]$ADERENTE),
min(new[COD_REG==paz_corrente]$eta_Min) +
as.integer(format(unique(new[COD_REG==paz_corrente]$data_studio_out), format="%Y")) -
as.integer(format(unique(new[COD_REG==paz_corrente]$data_rif_ev), format="%Y")),
tail(data[COD_REG==paz_corrente]$comorbidity,n=1),unique(new[COD_REG==paz_corrente]$death))
names(temp) <- names(data)
attributes(temp$timeEvent)<-attributes(data$timeEvent)
data <- rbind(data,temp)
}
# sort data
data <- data[order(COD_REG),]
## Arrange variables
data$COD_REG= factor(data$COD_REG)
data$status = factor('na')
for( i in 1:dim(data)[1]){
if(data[i]$event==1)
data[i]$status="hospitalization"
else {
if(data[i]$cens==0)
data[i]$status="censored"
else
data[i]$status="dead"
}
}
data$ADERENTE=factor(data$ADERENTE)
## Plot: multiple events & death as non-informative censoring
data_head=data[1:15,]
data_head$time_y=data_head$timeEvent/365
data_head$event=factor(data_head$event, labels=c('terminal','recurrent'))
ggplot(data=data_head,aes(x=COD_REG,y=as.double(time_y),group=COD_REG)) +
geom_line()+
geom_point(aes(color=event,shape=status),size=3)+
xlab("ID")+
ylab("years")+
coord_flip()
## Pass to gap times between events
data[,GapEvent:=as.integer(timeEvent)-as.integer(shift(timeEvent)),by=COD_REG]
data<-data[!is.na(GapEvent)]
## COXME model
coxme.mod <- coxme(Surv(GapEvent,event) ~ SESSO + ADERENTE + etaEvent + comorbidity + (1|COD_REG), data = data)
coxme.mod
A=matrix(0,9,9)
A[1,]=[0,1,0.25,0,0,0,0,0,0.25]
A[1,:]=[0,1,0.25,0,0,0,0,0,0.25]
A(1,:)=[0,1,0.25,0,0,0,0,0,0.25]
A(1,)=[0,1,0.25,0,0,0,0,0,0.25]
A(1,)=c(0,1,0.25,0,0,0,0,0,0.25)
A[1,1]
A[1,]
A[1,]=c(0,1,0.25,0,0,0,0,0,0.25)
A=matrix(0,9,9)
A[1,]=c(0,1,-0.25,0,0,0,0,0,-0.25)
A[2,]=c(-0.25,-0.25,1,-0.25,0,0,0,0,0)
A[3,]=c(0,0,-0.25,1,-0.25,0,0,0,0)
A[4,]=c(-0.25,-0.25,0,0,0,0,0,-0.25,1)
A[5,]=c(1,0,-0.25,0,-0.25,0,-0.25,0,-0.25)
A[6,]=c(-0.25,0,0,-0.25,-0.25,-0.25,0,0,0)
A[7,]=c(0,0,0,0,0,0,-0.25,1,-0.25)
A[8,]=c(-0.25,0,0,0,0,-0.25,1,-0.25,0)
A[9,]=c(0,0,0,0,-0.25,1,-0.25,0,0)
A
A[6,]=c(-0.25,0,0,-0.25,1,-0.25,0,0,0)
A
b=matrix(1,9,1)
b
solve(A,b)
library(frailtypack)
help("frailtypenal")
help("frailtyPenal")
sessionInfo()
library(openblasctl)
install.packages("openblasctl")
Rsys.getenv()
Sys.getenv()
library(secr)
install.packages("secr")
library(secr)
setNumThreads()
library(parallel)
detectCores()
detectCores(logical=FALSE)
Sys.getenv()
setwd("~/")
setwd("C:/Users/aughi/Desktop/TESI/Code/First_run_FFU_ACE")
load("C:/Users/aughi/Desktop/TESI/Code/First_run_FFU_ACE/Omega_FFU_ACE.RData")
load("C:/Users/aughi/Desktop/TESI/Code/First_run_FFU_ACE/Phi_FFU_ACE.RData")
load("C:/Users/aughi/Desktop/TESI/Code/First_run_FFU_ACE/Summary_FFU_ACE.RData")
FFU:try
FFU_try
plot(Omega0[(nbeta+ngamma+1):(nbeta+ngamma+npatients)],Omega0[(nbeta+ngamma+npatients+1):(nbeta+ngamma+2*npatients)])
nbeta=4
ngamma=4
npatients=3232
plot(Omega0[(nbeta+ngamma+1):(nbeta+ngamma+npatients)],Omega0[(nbeta+ngamma+npatients+1):(nbeta+ngamma+2*npatients)])
d=dist(Omega0[(nbeta+ngamma+1):(nbeta+ngamma+npatients)],Omega0[(nbeta+ngamma+npatients+1):(nbeta+ngamma+2*npatients)])
